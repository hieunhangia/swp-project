package com.swp.project.service.user;

import com.swp.project.dto.ChangePasswordDto;
import com.swp.project.dto.RegisterDto;
import com.swp.project.entity.PendingRegister;
import com.swp.project.entity.Role;
import com.swp.project.entity.User;
import com.swp.project.listener.event.UserDisabledEvent;
import com.swp.project.repository.user.UserRepository;
import com.swp.project.repository.user.PendingRegisterRepository;
import com.swp.project.service.EmailService;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.security.SecureRandom;
import java.time.Instant;
import java.util.*;

@RequiredArgsConstructor
@Service
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final RoleService roleService;
    private final PendingRegisterRepository pendingRegisterRepository;
    private final EmailService emailService;
    private final UserAiService userAiService;
    private final ApplicationEventPublisher eventPublisher;
    private final SecureRandom secureRandom = new SecureRandom();

    private void save(User user) {
        userRepository.save(user);
        userAiService.saveUserToVectorStore(user);
    }

    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }

    public User getUserByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    public boolean isUserExistsById(Long id) {
        return userRepository.existsById(id);
    }

    public boolean isUserExistsByEmail(String email) {
        return userRepository.existsByEmail(email);
    }

    public Page<User> getAllManagers(Pageable pageable) {
        return userRepository.getAllManagers(pageable);
    }

    @Transactional
    public void setUserEnabledStatus(Long id, boolean status) {
        if (id == null || !isUserExistsById(id)) {
            throw new RuntimeException("A user in the list was not found, all changes aborted");
        }
        User user = getUserById(id);
        user.setEnabled(status);

        if (!status) {
            eventPublisher.publishEvent(new UserDisabledEvent(user.getEmail()));
        }

        save(user);

    }

    @Transactional
    public void register(RegisterDto dto) {
        if (!dto.getConfirmPassword().equals(dto.getPassword())) {
            throw new RuntimeException("Password and confirm password do not match");
        }
        if (userRepository.existsByEmail(dto.getEmail())) {
            throw new RuntimeException("Email '" + dto.getEmail() + "' is already taken");
        }
        PendingRegister existedPendingRegister = pendingRegisterRepository.findByEmail(dto.getEmail());
        if (existedPendingRegister != null) {
            pendingRegisterRepository.delete(existedPendingRegister);
        }
        String autoGeneratedOtp = new Random().nextInt(100000, 1000000) + "";
        PendingRegister pendingRegister = PendingRegister.builder()
                .email(dto.getEmail())
                .passwordHash(passwordEncoder.encode(dto.getPassword()))
                .autoGeneratedOtp(autoGeneratedOtp)
                .otpExpiryTime(Instant.now().plusSeconds(300)) // OTP valid for 5 minutes
                .build();

        emailService.sendSimpleEmail(dto.getEmail(),
                "Verify your email - Your Account",
                "Your OTP for email verification is: " + autoGeneratedOtp +
                        "\n\nThis OTP is valid for 5 minutes. If you did not request this, please ignore this email.");

        pendingRegisterRepository.save(pendingRegister);
    }

    @Transactional
    public void verifyOtp(String email, String inputOtp) {
        PendingRegister pendingRegister = pendingRegisterRepository.findByEmail(email);
        if (!pendingRegister.getAutoGeneratedOtp().equals(inputOtp)
                || pendingRegister.getOtpExpiryTime().isBefore(Instant.now())) {
            throw new RuntimeException("Invalid OTP or OTP has expired");
        }
        User user = User.builder()
                .email(pendingRegister.getEmail())
                .password(pendingRegister.getPasswordHash())
                .role(roleService.getUserRole())
                .build();
        save(user);
        pendingRegisterRepository.delete(pendingRegister);
    }

    @Scheduled(fixedRate = 7200000) //Cleanup every 2 hours
    @Transactional
    public void cleanupExpiredPendingRegistrations() {
        Instant now = Instant.now();
        pendingRegisterRepository.deleteByOtpExpiryTimeBefore(now);
    }

    @Transactional
    public void changePassword(String email, ChangePasswordDto dto) {

        User user = getUserByEmail(email);

        if (!dto.getNewPassword().equals(dto.getConfirmNewPassword())) {
            throw new RuntimeException("New password and confirm new password do not match");
        }

        if (!passwordEncoder.matches(dto.getOldPassword(), user.getPassword())) {
            throw new RuntimeException("Current password is incorrect");
        }

        user.setPassword(passwordEncoder.encode(dto.getNewPassword()));
        save(user);
    }

    @Transactional
    public void forgotPassword(String email) {
        User user = getUserByEmail(email);

        if (user == null) throw new RuntimeException("No user found with email: " + email);

        if (user.getPassword() == null) {
            throw new RuntimeException("User is not registered with email and password authentication");
        }

        String newPassword = generateSecureRandomPassword();
        user.setPassword(passwordEncoder.encode(newPassword));
        save(user);

        emailService.sendSimpleEmail(user.getEmail(),
                "Password Reset - Your Account",
                "Your password has been reset. Your new temporary password is: " + newPassword +
                        "\n\nPlease log in and change your password immediately for security reasons.");
    }

    private String generateSecureRandomPassword() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
        StringBuilder password = new StringBuilder();
        for (int i = 0; i < 12; i++) {
            password.append(chars.charAt(secureRandom.nextInt(chars.length())));
        }
        return password.toString();
    }

    @Transactional
    public User registerWithGoogle(String email) {
        User user = User.builder()
                .email(email)
                .role(roleService.getUserRole())
                .build();
        save(user);
        return user;
    }

    @Value("${admin.email}")
    private String adminEmail;
    @Value("${admin.password}")
    private String adminPassword;

    @Transactional
    public void initDefaultUser() {
        createUserIfNotExists(User.builder()
                .email(adminEmail)
                .password(adminPassword)
                .build(), roleService.getAdminRole());
        createUserIfNotExists(User.builder()
                .email("default@default.com")
                .password("default")
                .build(), roleService.getUserRole());
        createUserIfNotExists(User.builder()
                .email("enabled@enabled.com")
                .password("enabled")
                .build(), roleService.getUserRole());
        createUserIfNotExists(User.builder()
                .email("disabled@disabled.com")
                .password("disabled")
                .enabled(false)
                .build(), roleService.getUserRole());
    }

    private void createUserIfNotExists(User user, Role role) {
        if (!userRepository.existsByEmail(user.getEmail())) {
            user.setPassword(passwordEncoder.encode(user.getPassword()));
            user.setRole(role);
            save(user);
        }
    }
}
