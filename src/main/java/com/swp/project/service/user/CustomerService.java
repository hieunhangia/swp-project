package com.swp.project.service.user;

import com.swp.project.dto.ChangePasswordDto;
import com.swp.project.dto.RegisterDto;
import com.swp.project.entity.PendingRegister;
import com.swp.project.entity.user.Customer;
import com.swp.project.repository.user.CustomerRepository;
import com.swp.project.repository.PendingRegisterRepository;
import com.swp.project.service.EmailService;
import lombok.RequiredArgsConstructor;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.security.SecureRandom;
import java.time.Instant;
import java.util.*;

@RequiredArgsConstructor
@Service
public class CustomerService {

    private final CustomerRepository customerRepository;
    private final PasswordEncoder passwordEncoder;
    private final PendingRegisterRepository pendingRegisterRepository;
    private final EmailService emailService;
    private final SecureRandom secureRandom = new SecureRandom();

    public Customer getCustomerByEmail(String email) {
        return customerRepository.getByEmail(email);
    }

    @Transactional
    public void register(RegisterDto dto) {
        if (!dto.getConfirmPassword().equals(dto.getPassword())) {
            throw new RuntimeException("Mật khẩu và xác nhận mật khẩu không khớp");
        }
        if (customerRepository.existsByEmail(dto.getEmail())) {
            throw new RuntimeException("Email " + dto.getEmail() + " đã được sử dụng");
        }
        PendingRegister existedPendingRegister = pendingRegisterRepository.findByEmail(dto.getEmail());
        if (existedPendingRegister != null) {
            pendingRegisterRepository.delete(existedPendingRegister);
        }
        String autoGeneratedOtp = new Random().nextInt(100000, 1000000) + "";
        PendingRegister pendingRegister = PendingRegister.builder()
                .email(dto.getEmail())
                .passwordHash(passwordEncoder.encode(dto.getPassword()))
                .autoGeneratedOtp(autoGeneratedOtp)
                .otpExpiryTime(Instant.now().plusSeconds(300))
                .build();

        emailService.sendSimpleEmail(dto.getEmail(),
                "Xác minh email của bạn",
                "OTP xác thực cho email của bạn:\n"
                        + autoGeneratedOtp
                        + "\n\nOTP này sẽ hết hạn sau 5 phút. Nếu bạn không yêu cầu OTP này, vui lòng bỏ qua email này.");

        pendingRegisterRepository.save(pendingRegister);
    }

    @Transactional
    public void verifyOtp(String email, String inputOtp) {
        PendingRegister pendingRegister = pendingRegisterRepository.findByEmail(email);
        if (!pendingRegister.getAutoGeneratedOtp().equals(inputOtp)
                || pendingRegister.getOtpExpiryTime().isBefore(Instant.now())) {
            throw new RuntimeException("OTP không hợp lệ hoặc đã hết hạn");
        }
        Customer customer = Customer.builder()
                .email(pendingRegister.getEmail())
                .password(pendingRegister.getPasswordHash())
                .build();
        customerRepository.save(customer);
        pendingRegisterRepository.delete(pendingRegister);
    }

    @Scheduled(fixedRate = 7200000) //Cleanup PendingRegister every 2 hours
    @Transactional
    public void cleanupExpiredPendingRegistrations() {
        Instant now = Instant.now();
        pendingRegisterRepository.deleteByOtpExpiryTimeBefore(now);
    }

    @Transactional
    public void changePassword(String email, ChangePasswordDto dto) {

        Customer customer = customerRepository.getByEmail(email);

        if (!dto.getNewPassword().equals(dto.getConfirmNewPassword())) {
            throw new RuntimeException("Mật khẩu mới và xác nhận mật khẩu mới không khớp");
        }

        if (!passwordEncoder.matches(dto.getOldPassword(), customer.getPassword())) {
            throw new RuntimeException("Mật khẩu cũ không đúng");
        }

        customer.setPassword(passwordEncoder.encode(dto.getNewPassword()));
        customerRepository.save(customer);
    }

    @Transactional
    public void forgotPassword(String email) {
        Customer customer = customerRepository.getByEmail(email);

        if (customer == null) throw new RuntimeException("Người dùng với email " + email + " không tồn tại");

        if (customer.getPassword() == null) {
            throw new RuntimeException("Tài khoản này được đăng ký bằng Google. Vui lòng sử dụng Google để đăng nhập.");
        }

        String newPassword = generateSecureRandomPassword();
        customer.setPassword(passwordEncoder.encode(newPassword));
        customerRepository.save(customer);

        emailService.sendSimpleEmail(email,
                "Khôi phục mật khẩu",
                "Mật khẩu vừa được đặt lại. Mật khẩu tạm thời của bạn là:\n"
                        + newPassword
                        + "\n\nVui lòng đăng nhập và thay đổi mật khẩu của bạn.");
    }

    private String generateSecureRandomPassword() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
        StringBuilder password = new StringBuilder();
        for (int i = 0; i < 12; i++) {
            password.append(chars.charAt(secureRandom.nextInt(chars.length())));
        }
        return password.toString();
    }

    @Transactional
    public Customer registerWithGoogle(String email) {
        Customer customer = Customer.builder()
                .email(email)
                .build();
        customerRepository.save(customer);
        return customer;
    }

    @Transactional
    public void initCustomer() {
        createCustomerIfNotExists(Customer.builder()
                .email("default-customer@shop.com")
                .password("customer")
                .build());
        String[] customers = {
                "alice", "bob", "charlie", "david", "emma", "frank", "grace", "henry",
                "isabella", "jack", "kate", "leo", "mia", "nathan", "olivia", "peter",
                "quinn", "ruby", "sam", "tina", "ursula", "victor", "wendy", "xander",
                "yara", "zane", "aaron", "bella", "carl", "diana", "elias", "fiona",
                "george", "hannah", "ivan", "julia"
        };
        for (String customer : customers) {
            createCustomerIfNotExists(Customer.builder()
                    .email(customer + "@customer.com")
                    .password(customer)
                    .build());
        }
    }

    private void createCustomerIfNotExists(Customer customer) {
        if (!customerRepository.existsByEmail(customer.getEmail())) {
            customer.setPassword(passwordEncoder.encode(customer.getPassword()));
            customerRepository.save(customer);
        }
    }
}
