package com.swp.project.service.user;

import com.swp.project.dto.RegisterDto;
import com.swp.project.entity.PendingRegister;
import com.swp.project.entity.user.Customer;
import com.swp.project.repository.PendingRegisterRepository;
import com.swp.project.repository.user.CustomerRepository;
import com.swp.project.repository.user.UserRepository;
import com.swp.project.service.EmailService;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.Instant;
import java.util.concurrent.ThreadLocalRandom;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@ExtendWith(MockitoExtension.class)
class CustomerServiceTest {

    @Mock
    private RegisterDto registerDto;
    @Mock
    private PendingRegister pendingRegister;
    @Mock
    private UserRepository userRepository;
    @Mock
    private PendingRegisterRepository pendingRegisterRepository;
    @Mock
    private ThreadLocalRandom threadLocalRandom;
    @Mock
    private PasswordEncoder passwordEncoder;
    @Mock
    private Instant instant;
    @Mock
    private EmailService emailService;
    @Mock
    private CustomerRepository customerRepository;
    @InjectMocks
    private CustomerService customerService;

    @Test
    @DisplayName("Register success when pending register does not exist")
    @Order(0)
    void register_Success_PendingRegisterNotExists() {
        when(registerDto.getEmail()).thenReturn("test@email.com");

        // password and confirmPassword match
        when(registerDto.getPassword()).thenReturn("password");
        when(registerDto.getConfirmPassword()).thenReturn("password");

        // email does not exist in the system
        when(userRepository.existsByEmail(registerDto.getEmail())).thenReturn(false);

        // pending registration for the email does not exist
        when(pendingRegisterRepository.findByEmail(registerDto.getEmail())).thenReturn(null);

        // mock auto generated OTP
        int autoGeneratedOtp = 36;
        when(threadLocalRandom.nextInt(anyInt(), anyInt())).thenReturn(autoGeneratedOtp);

        // mock password encoding
        String encodedPassword = "encodedPassword";
        when(passwordEncoder.encode(anyString())).thenReturn(encodedPassword);

        // mock instant.plusSeconds()
        Instant mockInstantTime = Instant.MIN;
        when(instant.plusSeconds(anyLong())).thenReturn(mockInstantTime);

        // mock sending email to do nothing
        doNothing().when(emailService).sendSimpleEmail(anyString(), anyString(), anyString());

        try (MockedStatic<ThreadLocalRandom> mockThreadLocalRandom = mockStatic(ThreadLocalRandom.class);
             MockedStatic<Instant> mockInstant = mockStatic(Instant.class)) {
            // mock ThreadLocalRandom.current()
            mockThreadLocalRandom.when(ThreadLocalRandom::current).thenReturn(threadLocalRandom);

            // mock Instant.now()
            mockInstant.when(Instant::now).thenReturn(instant);

            assertDoesNotThrow(() -> customerService.register(registerDto));
        }

        // verify pendingRegisterRepository.delete() is never called
        verify(pendingRegisterRepository,never()).delete(any());

        ArgumentCaptor<String> emailCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> textCaptor = ArgumentCaptor.forClass(String.class);
        // verify emailService.sendSimpleEmail() is called
        verify(emailService).sendSimpleEmail(emailCaptor.capture(), anyString(), textCaptor.capture());

        // assert email and text content for sending email are correct
        assertEquals(registerDto.getEmail(), emailCaptor.getValue());
        assertTrue(textCaptor.getValue().contains(String.valueOf(autoGeneratedOtp)));

        ArgumentCaptor<PendingRegister> pendingRegisterCaptor = ArgumentCaptor.forClass(PendingRegister.class);
        // verify pendingRegisterRepository.save() is called
        verify(pendingRegisterRepository).save(pendingRegisterCaptor.capture());

        // assert the saved PendingRegister has correct values
        PendingRegister savedPendingRegister = pendingRegisterCaptor.getValue();
        assertEquals(registerDto.getEmail(), savedPendingRegister.getEmail());
        assertEquals(encodedPassword, savedPendingRegister.getPasswordHash());
        assertEquals(String.valueOf(autoGeneratedOtp), savedPendingRegister.getAutoGeneratedOtp());
        assertEquals(mockInstantTime, savedPendingRegister.getOtpExpiryTime());
    }


    @Test
    @DisplayName("Register fails when password and confirmPassword do not match")
    @Order(1)
    void register_Fail_PasswordAndConfirmPasswordNotMatch() {
        when(registerDto.getPassword()).thenReturn("password");
        when(registerDto.getConfirmPassword()).thenReturn("passwordxxx");

        assertThrows(RuntimeException.class, () -> customerService.register(registerDto),
                "Mật khẩu và xác nhận mật khẩu không khớp");
    }

    @Test
    @DisplayName("Register fails when email already exists")
    @Order(2)
    void register_Fail_EmailAlreadyExists() {
        when(registerDto.getEmail()).thenReturn("test@email.com");

        // password and confirmPassword match
        when(registerDto.getPassword()).thenReturn("password");
        when(registerDto.getConfirmPassword()).thenReturn("password");

        // email exists in the system
        when(userRepository.existsByEmail(registerDto.getEmail())).thenReturn(true);

        assertThrows(RuntimeException.class, () -> customerService.register(registerDto),
                "Email " + registerDto.getEmail() + " đã được sử dụng");
    }

    @Test
    @DisplayName("Register fails when sending email failed and pending register already exists")
    @Order(3)
    void register_Fail_SendEmailFailed_PendingRegisterAlreadyExists() {
        when(registerDto.getEmail()).thenReturn("test@email.com");

        // password and confirmPassword match
        when(registerDto.getPassword()).thenReturn("password");
        when(registerDto.getConfirmPassword()).thenReturn("password");

        // email does not exist in the system
        when(userRepository.existsByEmail(registerDto.getEmail())).thenReturn(false);

        // pending registration for the email already exists
        when(pendingRegisterRepository.findByEmail(registerDto.getEmail())).thenReturn(new PendingRegister());

        // mock sending email to throw exception
        doThrow(RuntimeException.class).when(emailService).sendSimpleEmail(anyString(), anyString(), anyString());

        assertThrows(RuntimeException.class, () -> customerService.register(registerDto), "Gửi email thất bại. Vui lòng thử lại sau.");

        // verify pendingRegisterRepository.delete() is called
        verify(pendingRegisterRepository).delete(any());
    }

    @Test
    @DisplayName("Verify OTP success")
    @Order(4)
    void verifyOtp_Success() {
        String email = "test@email.com";

        // auto generated OTP and input OTP match
        String inputOtp = "36";
        when(pendingRegister.getAutoGeneratedOtp()).thenReturn(inputOtp);

        // OTP is not expired
        when(pendingRegister.getOtpExpiryTime()).thenReturn(Instant.now().plusSeconds(36));

        // mock finding pending register by email
        when(pendingRegisterRepository.findByEmail(anyString())).thenReturn(pendingRegister);

        assertDoesNotThrow(() -> customerService.verifyOtp(email, inputOtp));

        ArgumentCaptor<Customer> customerCaptor = ArgumentCaptor.forClass(Customer.class);
        // verify customerRepository.save() is called
        verify(customerRepository).save(customerCaptor.capture());

        // assert the saved Customer has correct values
        Customer savedCustomer = customerCaptor.getValue();
        assertEquals(pendingRegister.getEmail(), savedCustomer.getEmail());

        ArgumentCaptor<PendingRegister> pendingRegisterCaptor = ArgumentCaptor.forClass(PendingRegister.class);
        // verify pendingRegisterRepository.delete() is called
        verify(pendingRegisterRepository).delete(pendingRegisterCaptor.capture());

        // assert deleted the correct PendingRegister
        PendingRegister deletedPendingRegister = pendingRegisterCaptor.getValue();
        assertEquals(pendingRegister.getEmail(), deletedPendingRegister.getEmail());
        assertEquals(pendingRegister.getAutoGeneratedOtp(), deletedPendingRegister.getAutoGeneratedOtp());
        assertEquals(pendingRegister.getOtpExpiryTime(), deletedPendingRegister.getOtpExpiryTime());
    }

    @Test
    @DisplayName("Verify OTP fails when auto generated OTP and input OTP do not match")
    @Order(5)
    void verifyOtp_Fail_AutoGeneratedOtpAndInputOtpNotMatch() {
        // auto generated OTP and input OTP do not match
        String inputOtp = "36";
        when(pendingRegister.getAutoGeneratedOtp()).thenReturn(inputOtp + "xxx");

        // mock finding pending register by email
        when(pendingRegisterRepository.findByEmail(anyString())).thenReturn(pendingRegister);

        assertThrows(RuntimeException.class, () -> customerService.verifyOtp("test@email.com", inputOtp),
                "OTP không hợp lệ hoặc đã hết hạn");
    }

    @Test
    @DisplayName("Verify OTP fails when OTP has expired")
    @Order(6)
    void verifyOtp_Fail_OtpHasExpired() {
        // auto generated OTP and input OTP match
        String inputOtp = "36";
        when(pendingRegister.getAutoGeneratedOtp()).thenReturn(inputOtp);

        // OTP is expired
        when(pendingRegister.getOtpExpiryTime()).thenReturn(Instant.now().minusSeconds(36));

        // mock finding pending register by email
        when(pendingRegisterRepository.findByEmail(anyString())).thenReturn(pendingRegister);

        assertThrows(RuntimeException.class, () -> customerService.verifyOtp("test@email.com", inputOtp),
                "OTP không hợp lệ hoặc đã hết hạn");
    }
}