package com.swp.project.service.user;

import com.swp.project.dto.RegisterDto;
import com.swp.project.entity.PendingRegister;
import com.swp.project.repository.PendingRegisterRepository;
import com.swp.project.repository.user.CustomerRepository;
import com.swp.project.repository.user.UserRepository;
import com.swp.project.service.EmailService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.Instant;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CustomerServiceTest {

    @Mock
    private RegisterDto registerDto;

    @Mock
    private PendingRegister pendingRegister;

    @Mock
    private UserRepository userRepository;

    @Mock
    private PendingRegisterRepository pendingRegisterRepository;

    @SuppressWarnings("unused")
    @Mock
    private PasswordEncoder passwordEncoder;

    @Mock
    private EmailService emailService;

    @Mock
    private CustomerRepository customerRepository;

    @InjectMocks
    private CustomerService customerService;

    @Test
    @DisplayName("Register success when pending register does not exist")
    void register_Success_PendingRegisterNotExists() {
        when(registerDto.getEmail()).thenReturn("test@email.com");

        // password and confirmPassword match
        when(registerDto.getPassword()).thenReturn("password");
        when(registerDto.getConfirmPassword()).thenReturn("password");

        // email does not exist in the system
        when(userRepository.existsByEmail(registerDto.getEmail())).thenReturn(false);

        // pending registration for the email does not exist
        when(pendingRegisterRepository.findByEmail(registerDto.getEmail())).thenReturn(null);

        assertDoesNotThrow(() -> customerService.register(registerDto));

        // verify pendingRegisterRepository.delete() is not called
        verify(pendingRegisterRepository,never()).delete(any());

        // verify emailService.sendSimpleEmail() is called
        verify(emailService).sendSimpleEmail(anyString(), anyString(), anyString());

        // verify pendingRegisterRepository.save() is called
        verify(pendingRegisterRepository).save(any());
    }


    @Test
    @DisplayName("Register fails when password and confirmPassword do not match")
    void register_Fail_PasswordAndConfirmPasswordNotMatch() {
        when(registerDto.getPassword()).thenReturn("password");
        when(registerDto.getConfirmPassword()).thenReturn("passwordxxx");

        assertThrows(RuntimeException.class, () -> customerService.register(registerDto),
                "Mật khẩu và xác nhận mật khẩu không khớp");
    }

    @Test
    @DisplayName("Register fails when email already exists")
    void register_Fail_EmailAlreadyExists() {
        when(registerDto.getEmail()).thenReturn("test@email.com");

        // password and confirmPassword match
        when(registerDto.getPassword()).thenReturn("password");
        when(registerDto.getConfirmPassword()).thenReturn("password");

        // email exists in the system
        when(userRepository.existsByEmail(registerDto.getEmail())).thenReturn(true);

        assertThrows(RuntimeException.class, () -> customerService.register(registerDto),
                "Email " + registerDto.getEmail()  + " đã được sử dụng");
    }

    @Test
    @DisplayName("Register fails when sending email failed and pending register already exists")
    void register_Fail_SendEmailFailed_PendingRegisterAlreadyExists() {
        when(registerDto.getEmail()).thenReturn("test@email.com");

        // password and confirmPassword match
        when(registerDto.getPassword()).thenReturn("password");
        when(registerDto.getConfirmPassword()).thenReturn("password");

        // email does not exist in the system
        when(userRepository.existsByEmail(registerDto.getEmail())).thenReturn(false);

        // pending registration for the email already exists
        when(pendingRegisterRepository.findByEmail(registerDto.getEmail())).thenReturn(new PendingRegister());

        // mock sending email to throw exception
        doThrow(RuntimeException.class).when(emailService).sendSimpleEmail(anyString(), anyString(), anyString());

        assertThrows(RuntimeException.class, () -> customerService.register(registerDto), "Gửi email thất bại. Vui lòng thử lại sau.");

        // verify pendingRegisterRepository.delete() is called
        verify(pendingRegisterRepository).delete(any());
    }

    @Test
    @DisplayName("Verify OTP success")
    void verifyOtp_Success(){
        // auto generated OTP and input OTP match
        String inputOtp = "36";
        when(pendingRegister.getAutoGeneratedOtp()).thenReturn(inputOtp);

        // OTP is not expired
        when(pendingRegister.getOtpExpiryTime()).thenReturn(Instant.now().plusSeconds(36));

        // mock finding pending register by email
        when(pendingRegisterRepository.findByEmail(anyString())).thenReturn(pendingRegister);

        customerService.verifyOtp("test@email.com", inputOtp);

        // verify customerRepository.save() is called
        verify(customerRepository).save(any());

        // verify pendingRegisterRepository.delete() is called
        verify(pendingRegisterRepository).delete(any());
    }

    @Test
    @DisplayName("Verify OTP fails when auto generated OTP and input OTP do not match")
    void verifyOtp_Fail_AutoGeneratedOtpAndInputOtpNotMatch(){
        // auto generated OTP and input OTP do not match
        String inputOtp = "36";
        when(pendingRegister.getAutoGeneratedOtp()).thenReturn(inputOtp + "xxx");

        // mock finding pending register by email
        when(pendingRegisterRepository.findByEmail(anyString())).thenReturn(pendingRegister);

        //
        assertThrows(RuntimeException.class, () -> customerService.verifyOtp("test@email.com", inputOtp),
                "OTP không hợp lệ hoặc đã hết hạn");
    }

    @Test
    @DisplayName("Verify OTP fails when OTP has expired")
    void verifyOtp_Fail_OtpHasExpired(){
        // auto generated OTP and input OTP match
        String inputOtp = "36";
        when(pendingRegister.getAutoGeneratedOtp()).thenReturn(inputOtp);

        // OTP is expired
        when(pendingRegister.getOtpExpiryTime()).thenReturn(Instant.now().minusSeconds(36));

        // mock finding pending register by email
        when(pendingRegisterRepository.findByEmail(anyString())).thenReturn(pendingRegister);

        assertThrows(RuntimeException.class, () -> customerService.verifyOtp("test@email.com", inputOtp),
                "OTP không hợp lệ hoặc đã hết hạn");
    }
}